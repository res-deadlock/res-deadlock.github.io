<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>动态规划刷题总结</title>
    <url>/2023/03/21/%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>电联后记</title>
    <url>/2023/03/17/%E9%9A%8F%E7%AC%94(1)/</url>
    <content><![CDATA[<p>刚刚又和妈妈通了电话，我是真的无奈啊。</p>
<span id="more"></span>
<p>回想起来，从回到学校以来，首先确定了最基本的春招目标，随后紧接着参加了3场宣讲会，大致弄清楚了校招的时间和流程。</p>
<p>凭借本科HUST的优势，后面投递的许多家公司都能接到笔试机会。笔试题一开始做得并不顺利，急需针对性的重读C++ Primer和Effective C++。由于笔试公司的要求，编程题需要解答网络编程问题，但这属于我的死穴，因为迄今为止我还没有针对网络编程进行系统性的训练。</p>
<p>知识上的欠缺像一把利刃，抵在背后，接着一点一点刺入。于是我很快意识到专项训练和项目的重要性。前者，需要进行“面向笔试题学习”；后者，需要找准自身定位，快速做一个符合条件的项目。</p>
<p>一开始的行动带有盲目性，胡乱找了一个httpd的项目。因为能力实在有限，我没有从主体上分析该项目是否符合我要求的能力，只能去试错。墨菲定律偏偏起效，这个项目只有半截。没有时间产生情绪，马上着手选择下一个项目，有一个高性能服务器还不错，但是太难了，既可惜又觉得，真是长见识了。</p>
<p>在更换项目的过程中，陆陆续续接了许多公司的笔试和面试，大多都以石沉大海收尾，我很清楚，我离“有所准备”甚至还差很远。</p>
<p>情势也不总是悲观的，至少有一点可以确定，如果没有频繁的试错，我不会找到一条适合自己的道路。大体方向是一致的，但具体道路是自适应的，我时常这样考虑，只要一直在学习对的知识，结果就不会太差吧。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>第一篇博客</title>
    <url>/2023/03/05/%E9%9A%8F%E7%AC%94/</url>
    <content><![CDATA[<p>截至2023年3月6日，我基本完成了个人博客站的搭建，采用<a href="https://hexo.io/">Hexo</a>框架和<a href="https://github.com/theme-next/hexo-theme-next">NexT</a>主题，整个过程非常顺利。</p>
<span id="more"></span>
<p>悟以往之不谏，知来者之可追。过去无可改变，未来充满变数，只有今天是天赐的礼物。我将在这里记录学习过程中的心得体会，成为更好的自己，从每一个“今天”开始。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题</title>
    <url>/2023/03/15/%E9%9D%A2%E8%AF%95/</url>
    <content><![CDATA[<h2 id="基础知识："><a href="#基础知识：" class="headerlink" title="基础知识："></a>基础知识：</h2><span id="more"></span>

<pre><code>进程间的通信方式
僵尸进程，孤儿进程
线程同步怎么解决
大端和小端的区别
IO多路复用有哪些方式，区别
静态库和动态库的制作以及使用
滑动窗口的机制
TCP3次握手，4次挥手
TCP和UDP的区别
……
</code></pre>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>项目基础——Linux编程——Makefile</title>
    <url>/2023/03/26/%E9%A1%B9%E7%9B%AE%E5%9F%BA%E7%A1%80(1)/</url>
    <content><![CDATA[<h2 id="文件命名"><a href="#文件命名" class="headerlink" title="文件命名"></a>文件命名</h2><p>Makefile 或 makefile</p>
<span id="more"></span>

<h2 id="Makefile-规则"><a href="#Makefile-规则" class="headerlink" title="Makefile 规则"></a>Makefile 规则</h2><ol>
<li>一个Makefile文件中可以有一个或多个规则，格式：</li>
</ol>
<blockquote>
<p>目标 … : 依赖 …<br>$~~~~~~$命令:（Shell命令）<br>$~~~~~~$……</p>
<ul>
<li>目标：最终要生成的文件（伪目标除外）</li>
<li>依赖：生成目标所需要的文件或者目标</li>
<li>命令：通过执行命令对依赖操作生成目标（命令前必须使用Tab缩进）</li>
</ul>
</blockquote>
<ol start="2">
<li><p>其他规则一般都是为第一条规则服务的。</p>
</li>
<li><p>make clean ：</p>
</li>
</ol>
<blockquote>
<p>clean:<br>$~~~~~~$rm xxx -f</p>
</blockquote>
<ol start="4">
<li>伪目标（不会生成伪目标对应的文件）<blockquote>
<p>.PHONY:伪目标的名称</p>
</blockquote>
</li>
</ol>
<p>$~~~$示例：</p>
<blockquote>
<p>.PHONY:clean<br>clean:<br>$~~~~~~$rm xxx -f</p>
</blockquote>
<p><strong>Makefile 默认执行第一条规则，如果后续规则和第一条规则没有关系，则不会执行（需要额外操作）</strong></p>
<h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><ol>
<li>命令在执行前，需要先检查规则中的依赖项是否存在</li>
</ol>
<blockquote>
<ul>
<li>如果存在，执行命令</li>
<li>如果不存在，向下检查其他规则，检查有没有一个规则是用来生成这个依赖的，如果找到了，则执行该规则中的命令</li>
</ul>
</blockquote>
<ol start="2">
<li>检测更新，在执行规则中的命令时，会比较目标和依赖文件的时间</li>
</ol>
<blockquote>
<ul>
<li>如果依赖的时间比目标的时间晚，需要重新生成目标</li>
<li>如果依赖的时间比目标的时间早，目标不需要更新，对应规则中的命令不需要被执行</li>
</ul>
</blockquote>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><ol>
<li>自定义变量<blockquote>
<p>变量名&#x3D;变量值  </p>
</blockquote>
</li>
<li>预定义变量<blockquote>
<p>AR: 归档维护程序的名称，默认值为ar<br>CC: C编译器的名称，默认值为gcc<br>CXX: C++编译器的名称，默认值为g++</p>
</blockquote>
</li>
</ol>
<blockquote>
<p>$@: 目标的完整路径<br>$&lt;: 第一个依赖文件的名称<br>$^: 所有的依赖文件<br><em>（以上三个为自动变量，只能在规则的“命令”中使用）</em><br>3. 获取变量的值<br>$(变量名)</p>
</blockquote>
<h2 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h2><p>通配符 ‘%’, 匹配的是同一个字符串，如下例，即main.c:main.o<br>可以将规则简化书写为 ：</p>
<pre><code>%.c:%.o
    gcc -c $&lt; -o $@
</code></pre>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ol>
<li><p>wildcard </p>
<blockquote>
<p>$(wildcard PATTERN…)</p>
<ul>
<li>功能：获取指定目录下指定类型的文件列表</li>
<li>参数：PARTTERN指的是某个或多个目录下对应的某种类型的文件</li>
<li>返回：得到的若干个文件的文件列表</li>
<li>示例：<br>$(wilecard *.c .&#x2F;sub&#x2F;*.c)<br>返回值格式: a.c b.c c.c d.c e.c f.c</li>
</ul>
</blockquote>
</li>
<li><p>patsubst</p>
<blockquote>
<p>#(patsubst &lt;pattern&gt;,&lt;replacement&gt;,&lt;text&gt;)</p>
<ul>
<li>功能：查找&lt;text&gt;中的单词是否符合模式&lt;pattern&gt;，如果匹配的话，则以&lt;replacement&gt;替换</li>
<li>&lt;pattern&gt;可以包括通配符 ‘%‘, 表示任意长度的字串。如果&lt;replacement&gt;中也包含’%‘，那么，&lt;replacement&gt;中的这个 ‘%‘ 将是&lt;pattern&gt;中那个 ‘%‘ 代表的字串（如果想要表示真实含义的’%‘符号，可以使用’&#39;进行转义）。</li>
<li>返回：函数返回被替换后的字符串</li>
<li>示例：<br>$(patsubst %.c, %.o, x.c bar.c)<br>返回值格式：x.o bar.o</li>
</ul>
</blockquote>
</li>
</ol>
]]></content>
      <categories>
        <category>项目基础</category>
      </categories>
      <tags>
        <tag>Makefile</tag>
      </tags>
  </entry>
  <entry>
    <title>项目基础——Linux编程——库</title>
    <url>/2023/03/08/%E9%A1%B9%E7%9B%AE%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>Linux高并发服务器开发（from NowCoder）<br>库的相关操作</p>
<h2 id="环境搭建："><a href="#环境搭建：" class="headerlink" title="环境搭建："></a>环境搭建：</h2><p>VmWare虚拟机；Xshell远程连接，WinSCP文件传输；VS Code</p>
<h2 id="配置虚拟环境"><a href="#配置虚拟环境" class="headerlink" title="配置虚拟环境"></a>配置虚拟环境</h2><p>网络配置，使用NAT模式，这个可以再了解一下，面试会问到。</p>
<span id="more"></span>
<h2 id="固定系统ip"><a href="#固定系统ip" class="headerlink" title="固定系统ip"></a>固定系统ip</h2><p>为了防止ip动态变化，需要更改Ubuntu的网络配置文件。<br>gcc 和 g++的使用以及区别</p>
<h2 id="静态库-amp-动态库-共享库"><a href="#静态库-amp-动态库-共享库" class="headerlink" title="静态库&amp;动态库(共享库)"></a>静态库&amp;动态库(共享库)</h2><h3 id="静态库命名规则："><a href="#静态库命名规则：" class="headerlink" title="静态库命名规则："></a>静态库命名规则：</h3><pre><code>Linux: libxxx.a
 lib: 前缀
 xxx: 自定义库名称
 .a: 后缀
Windows: libxxx.lib
</code></pre>
<h3 id="静态库的制作："><a href="#静态库的制作：" class="headerlink" title="静态库的制作："></a>静态库的制作：</h3><pre><code>gcc获得.o文件
将.o文件打包，使用ar工具（archive）
 ar rcs libxxx.a xxx.o xxx.o
  r - 将文件插入备份文件中
  c - 建立备存文件
  s - 索引
</code></pre>
<h3 id="静态库的使用："><a href="#静态库的使用：" class="headerlink" title="静态库的使用："></a>静态库的使用：</h3><pre><code>gcc -o app main.c -I ./include -l calc -L ./lib
 -I 添加头文件
 -l 指明库名称（不是库文件名称）
 -L 指出库的路径
</code></pre>
<h3 id="动态库命名规则："><a href="#动态库命名规则：" class="headerlink" title="动态库命名规则："></a>动态库命名规则：</h3><pre><code>Linux: libxxx.so
 lib: 前缀
 xxx: 自定义库名称
 .so: 后缀
 在Linux下是一个可执行文件
Windows: libxxx.dll
</code></pre>
<h3 id="动态库的制作："><a href="#动态库的制作：" class="headerlink" title="动态库的制作："></a>动态库的制作：</h3><pre><code>gcc得到.o文件，得到和位置无关的代码
 gcc -c -fpic/fPIC a.c b.c
gcc得到动态库
 gcc -shared a.o b.o -o libcalc.so
</code></pre>
<p>动态库在链接阶段不会被打包到可执行程序中，而是在程序运行后，当使用到动态库里的API时，由动态载入器获取动态库的绝对路径，找到后再将其载入内存。</p>
<h3 id="查看动态库依赖关系"><a href="#查看动态库依赖关系" class="headerlink" title="查看动态库依赖关系"></a>查看动态库依赖关系</h3><pre><code>ldd xxx
 xxx: 可执行程序名
</code></pre>
<h3 id="动态库配置"><a href="#动态库配置" class="headerlink" title="动态库配置"></a>动态库配置</h3><p>1.配置环境变量LD_LIBRARY_PATH</p>
<pre><code>暂时配置：
 终端执行命令: export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:动态库绝对路径

 永久配置：
  用户级：
   vim ~/.bashrc
   在末尾添加: export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:动态库绝对路径
   修改完成后使修改生效，执行: . ~/.bashrc 或者 source ~/.bashrc

  系统级：
   sudo vim /etc/profile
   在末尾添加: export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:动态库绝对路径
   修改完成后使修改生效，执行: source /etc/profile
</code></pre>
<p>2.修改 &#x2F;etc&#x2F;ld.so.cache 文件</p>
<pre><code>sudo vim /etc/ld.so.conf
把动态库的绝对路径添加进去
修改完成后更新，执行: sudo ldconfig
</code></pre>
<p>3.在 &#x2F;lib&#x2F;, &#x2F;usr&#x2F;lib 目录下修改</p>
<pre><code>不建议使用
</code></pre>
<h3 id="优缺点和使用"><a href="#优缺点和使用" class="headerlink" title="优缺点和使用"></a>优缺点和使用</h3><p>如果库比较小，考虑使用静态库，反之，使用动态库</p>
<ol>
<li>静态库<br>优点：加载速度快；发布程序无需提供静态库，移植方便<br>缺点：消耗系统资源；更新、部署、发布麻烦</li>
<li>动态库<br>优点：可以实现进程资源共享；更新、部署、发布简单；可以控制何时加载<br>缺点：加载速度比静态库慢；发布程序时需要提供动态库</li>
</ol>
]]></content>
      <categories>
        <category>项目基础</category>
      </categories>
      <tags>
        <tag>库</tag>
      </tags>
  </entry>
</search>

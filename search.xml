<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>动态规划刷题总结</title>
    <url>/2023/03/21/%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>电联后记</title>
    <url>/2023/03/17/%E9%9A%8F%E7%AC%94(1)/</url>
    <content><![CDATA[<p>刚刚又和妈妈通了电话，我是真的无奈啊。</p>
<span id="more"></span>
<p>回想起来，从回到学校以来，首先确定了最基本的春招目标，随后紧接着参加了3场宣讲会，大致弄清楚了校招的时间和流程。</p>
<p>凭借本科HUST的优势，后面投递的许多家公司都能接到笔试机会。笔试题一开始做得并不顺利，急需针对性的重读C++ Primer和Effective C++。由于笔试公司的要求，编程题需要解答网络编程问题，但这属于我的死穴，因为迄今为止我还没有针对网络编程进行系统性的训练。</p>
<p>知识上的欠缺像一把利刃，抵在背后，接着一点一点刺入。于是我很快意识到专项训练和项目的重要性。前者，需要进行“面向笔试题学习”；后者，需要找准自身定位，快速做一个符合条件的项目。</p>
<p>一开始的行动带有盲目性，胡乱找了一个httpd的项目。因为能力实在有限，我没有从主体上分析该项目是否符合我要求的能力，只能去试错。墨菲定律偏偏起效，这个项目只有半截。没有时间产生情绪，马上着手选择下一个项目，有一个高性能服务器还不错，但是太难了，既可惜又觉得，真是长见识了。</p>
<p>在更换项目的过程中，陆陆续续接了许多公司的笔试和面试，大多都以石沉大海收尾，我很清楚，我离“有所准备”甚至还差很远。</p>
<p>情势也不总是悲观的，至少有一点可以确定，如果没有频繁的试错，我不会找到一条适合自己的道路。大体方向是一致的，但具体道路是自适应的，我时常这样考虑，只要一直在学习对的知识，结果就不会太差吧。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>第一篇博客</title>
    <url>/2023/03/05/%E9%9A%8F%E7%AC%94/</url>
    <content><![CDATA[<p>截至2023年3月6日，我基本完成了个人博客站的搭建，采用<a href="https://hexo.io/">Hexo</a>框架和<a href="https://github.com/theme-next/hexo-theme-next">NexT</a>主题，整个过程非常顺利。</p>
<span id="more"></span>
<p>悟以往之不谏，知来者之可追。过去无可改变，未来充满变数，只有今天是天赐的礼物。我将在这里记录学习过程中的心得体会，成为更好的自己，从每一个“今天”开始。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>项目基础——Linux编程——Makefile</title>
    <url>/2023/03/26/%E9%A1%B9%E7%9B%AE%E5%9F%BA%E7%A1%80(1)/</url>
    <content><![CDATA[<h2 id="文件命名"><a class="markdownIt-Anchor" href="#文件命名"></a> 文件命名</h2>
<p>Makefile 或 makefile</p>
<span id="more"></span>
<h2 id="makefile-规则"><a class="markdownIt-Anchor" href="#makefile-规则"></a> Makefile 规则</h2>
<ol>
<li>一个Makefile文件中可以有一个或多个规则，格式：</li>
</ol>
<blockquote>
<p>目标 … : 依赖 …<br>
 命令:（Shell命令）<br>
 ……</p>
<ul>
<li>目标：最终要生成的文件（伪目标除外）</li>
<li>依赖：生成目标所需要的文件或者目标</li>
<li>命令：通过执行命令对依赖操作生成目标（命令前必须使用Tab缩进）</li>
</ul>
</blockquote>
<ol start="2">
<li>
<p>其他规则一般都是为第一条规则服务的。</p>
</li>
<li>
<p>make clean ：</p>
</li>
</ol>
<blockquote>
<p>clean:<br>
 rm xxx -f</p>
</blockquote>
<ol start="4">
<li>伪目标（不会生成伪目标对应的文件）</li>
</ol>
<blockquote>
<p>.PHONY:伪目标的名称</p>
</blockquote>
<p> 示例：</p>
<blockquote>
<p>.PHONY:clean<br>
clean:<br>
 rm xxx -f</p>
</blockquote>
<p><strong>Makefile 默认执行第一条规则，如果后续规则和第一条规则没有关系，则不会执行（需要额外操作）</strong></p>
<h2 id="工作原理"><a class="markdownIt-Anchor" href="#工作原理"></a> 工作原理</h2>
<ol>
<li>命令在执行前，需要先检查规则中的依赖项是否存在</li>
</ol>
<blockquote>
<ul>
<li>如果存在，执行命令</li>
<li>如果不存在，向下检查其他规则，检查有没有一个规则是用来生成这个依赖的，如果找到了，则执行该规则中的命令</li>
</ul>
</blockquote>
<ol start="2">
<li>检测更新，在执行规则中的命令时，会比较目标和依赖文件的时间</li>
</ol>
<blockquote>
<ul>
<li>如果依赖的时间比目标的时间晚，需要重新生成目标</li>
<li>如果依赖的时间比目标的时间早，目标不需要更新，对应规则中的命令不需要被执行</li>
</ul>
</blockquote>
<h2 id="变量"><a class="markdownIt-Anchor" href="#变量"></a> 变量</h2>
<ol>
<li>自定义变量</li>
</ol>
<blockquote>
<p>变量名=变量值</p>
</blockquote>
<ol start="2">
<li>预定义变量</li>
</ol>
<blockquote>
<p>AR: 归档维护程序的名称，默认值为ar<br>
CC: C编译器的名称，默认值为gcc<br>
CXX: C++编译器的名称，默认值为g++</p>
<p>$@: 目标的完整路径<br>
$&lt;: 第一个依赖文件的名称<br>
$^: 所有的依赖文件<br>
<em>（以上三个为自动变量，只能在规则的“命令”中使用）</em></p>
</blockquote>
<ol start="3">
<li>获取变量的值</li>
</ol>
<blockquote>
<p>$(变量名)</p>
</blockquote>
<h2 id="模式匹配"><a class="markdownIt-Anchor" href="#模式匹配"></a> 模式匹配</h2>
<p>通配符 ‘%’, 匹配的是同一个字符串，如下例，即main.c:main.o<br>
可以将规则简化书写为 ：</p>
<pre><code>%.c:%.o
    gcc -c $&lt; -o $@
</code></pre>
<h2 id="函数"><a class="markdownIt-Anchor" href="#函数"></a> 函数</h2>
<ol>
<li>wildcard</li>
</ol>
<blockquote>
<p>$(wildcard PATTERN…)</p>
<ul>
<li>功能：获取指定目录下指定类型的文件列表</li>
<li>参数：PARTTERN指的是某个或多个目录下对应的某种类型的文件</li>
<li>返回：得到的若干个文件的文件列表</li>
<li>示例：<br>
$(wilecard *.c ./sub/*.c)<br>
返回值格式: a.c b.c c.c d.c e.c f.c</li>
</ul>
</blockquote>
<ol start="2">
<li>patsubst</li>
</ol>
<blockquote>
<p>$(patsubst &lt;pattern&gt;,&lt;replacement&gt;,&lt;text&gt;)</p>
<ul>
<li>功能：查找&lt;text&gt;中的单词是否符合模式&lt;pattern&gt;，如果匹配的话，则以&lt;replacement&gt;替换</li>
<li>&lt;pattern&gt;可以包括通配符 ‘%’, 表示任意长度的字串。如果&lt;replacement&gt;中也包含’%‘，那么，&lt;replacement&gt;中的这个 ‘%’ 将是&lt;pattern&gt;中那个 ‘%’ 代表的字串（如果想要表示真实含义的’%‘符号，可以使用’'进行转义）。</li>
<li>返回：函数返回被替换后的字符串</li>
<li>示例：<br>
$(patsubst %.c, %.o, x.c bar.c)<br>
返回值格式：x.o bar.o</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>项目基础</category>
      </categories>
      <tags>
        <tag>Makefile</tag>
      </tags>
  </entry>
  <entry>
    <title>项目基础——Linux编程——GDB调试</title>
    <url>/2023/03/26/%E9%A1%B9%E7%9B%AE%E5%9F%BA%E7%A1%80(2)/</url>
    <content><![CDATA[<p>为调试编译时：<br>
关掉优化选项（‘-On’），打开调试选项（‘-g’），打开warnings（‘-Wall’）</p>
<pre><code>gcc -g -Wall program.c -o program
</code></pre>
<span id="more"></span>
<p><strong>直接在命令行使用GDB很不舒服，和VS Code结合使用会好很多，建议在VS Code上配置。</strong></p>
<h2 id="gdb命令"><a class="markdownIt-Anchor" href="#gdb命令"></a> GDB命令</h2>
<h3 id="启动-退出-查看"><a class="markdownIt-Anchor" href="#启动-退出-查看"></a> 启动、退出、查看</h3>
<ul>
<li>启动和退出
<blockquote>
<p>gdb 可执行程序<br>
quit</p>
</blockquote>
</li>
<li>给程序设置参数/获取参数
<blockquote>
<p>set args 10 20<br>
show args</p>
</blockquote>
</li>
<li>GDB使用帮助
<blockquote>
<p>help</p>
</blockquote>
</li>
<li>查看当前文件代码
<blockquote>
<p>list/1<br>
list 或 l （默认位置显示）<br>
list/l 行号（从指定的行显示）<br>
list/l 函数名（从指定的函数显示）</p>
</blockquote>
</li>
<li>查看非当前文件代码
<blockquote>
<p>list/l 文件名:行号<br>
list/l 文件名:函数名</p>
</blockquote>
</li>
<li>设置显示的行数
<blockquote>
<p>show list/listsize<br>
set list/listsize 行数</p>
</blockquote>
</li>
</ul>
<h3 id="断点操作"><a class="markdownIt-Anchor" href="#断点操作"></a> 断点操作</h3>
<ul>
<li>设置断点
<blockquote>
<p>b/break 行号<br>
b/break 函数名<br>
b/break 文件名:行号<br>
b/break 文件名:函数名</p>
</blockquote>
</li>
<li>查看断点
<blockquote>
<p>i/info b/break</p>
</blockquote>
</li>
<li>删除断点
<blockquote>
<p>d/del/delete 断点编号</p>
</blockquote>
</li>
<li>设置断点无效
<blockquote>
<p>dis/disable 断点编号</p>
</blockquote>
</li>
<li>设置断点生效
<blockquote>
<p>ena/enable 断点编号</p>
</blockquote>
</li>
<li>设置条件断点（一般用在循环的位置）
<blockquote>
<p>b/break 行号 if 条件</p>
</blockquote>
</li>
</ul>
<h3 id="调试命令"><a class="markdownIt-Anchor" href="#调试命令"></a> 调试命令</h3>
<ul>
<li>运行GDB程序
<blockquote>
<p>start（程序停在第一行）<br>
run（遇到断点才停）</p>
</blockquote>
</li>
<li>继续运行，到下一个断点停
<blockquote>
<p>c/continue</p>
</blockquote>
</li>
<li>向下执行一行代码（不会进入函数体）
<blockquote>
<p>n/next</p>
</blockquote>
</li>
<li>变量操作
<blockquote>
<p>p/print 变量名（打印变量值）<br>
ptype 变量名（打印变量类型）</p>
</blockquote>
</li>
<li>向下单步调试（遇到函数进入函数体）
<blockquote>
<p>s/step<br>
finish（跳出函数体）</p>
</blockquote>
</li>
<li>自动变量操作
<blockquote>
<p>display num（自动打印指定变量的值）<br>
i/info display<br>
undisplay 编号</p>
</blockquote>
</li>
<li>其他操作
<blockquote>
<p>set var 变量名=变量值<br>
until（跳出循环）</p>
</blockquote>
</li>
</ul>
<h3 id="多进程调试"><a class="markdownIt-Anchor" href="#多进程调试"></a> 多进程调试</h3>
<p><strong>GDB默认只能跟踪一个进程</strong>，可以在 fork 函数调用之前，通过指令设置 GDB 调试工具跟踪父进程或者是跟踪子进程，<strong>默认跟踪父进程</strong>。</p>
<p>设置调试父进程或者子进程：</p>
<pre><code>set follow-fork-mode [parent（默认）| child]
</code></pre>
<p>设置调试模式</p>
<pre><code>set detach-on-fork [on | off]
</code></pre>
<p>默认为 on，表示调试当前进程的时候，其它的进程继续运行，如果为 off，调试当前进<br>
程的时候，其它进程被 GDB 挂起。</p>
<p>查看调试的进程：</p>
<pre><code>info inferiors
</code></pre>
<p>切换当前调试的进程：</p>
<pre><code>inferior id
</code></pre>
<p>使进程脱离 GDB 调试：</p>
<pre><code>detach inferiors id
</code></pre>
]]></content>
      <categories>
        <category>项目基础</category>
      </categories>
      <tags>
        <tag>GDB</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题</title>
    <url>/2023/03/15/%E9%9D%A2%E8%AF%95/</url>
    <content><![CDATA[<h2 id="基础知识"><a class="markdownIt-Anchor" href="#基础知识"></a> 基础知识：</h2>
<span id="more"></span>
<pre><code>进程间的通信方式
僵尸进程，孤儿进程
线程同步怎么解决
大端和小端的区别
IO多路复用有哪些方式，区别
静态库和动态库的制作以及使用
滑动窗口的机制
TCP3次握手，4次挥手
TCP和UDP的区别
……
</code></pre>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>项目基础——Linux多进程编程——父子进程</title>
    <url>/2023/03/31/%E9%A1%B9%E7%9B%AE%E5%9F%BA%E7%A1%80(3)/</url>
    <content><![CDATA[<p>读时共享，写时拷贝</p>
]]></content>
      <categories>
        <category>项目基础</category>
      </categories>
      <tags>
        <tag>process</tag>
      </tags>
  </entry>
  <entry>
    <title>项目基础——Linux多进程编程——exec函数族</title>
    <url>/2023/03/31/%E9%A1%B9%E7%9B%AE%E5%9F%BA%E7%A1%80(4)/</url>
    <content><![CDATA[<ol>
<li>exec 函数族的作用是根据指定的文件名找到可执行文件，并用它来取代调用进程的内容，换句话说，就是在调用进程内部执行一个可执行文件 <em>（一般在使用中，我们会先fork一个子进程，在子进程中调用exec打开指定文件，从而在子进程运行）。</em></li>
</ol>
<span id="more"></span>
<ol start="2">
<li>exec 函数族的函数执行成功后不会返回，因为调用进程的实体，包括代码段，数据段和堆栈等都已经被新的内容取代，只留下进程 ID 等一些表面上的信息仍保持原样，颇有些神似“三十六计”中的“金蝉脱壳”。看上去还是旧的躯壳，却已经注入了新的灵魂，只有调用失败了，才会返回-1.</li>
</ol>
<h2 id="工作方式"><a class="markdownIt-Anchor" href="#工作方式"></a> 工作方式</h2>
<p><img src="/resources/exec.jpg" alt="avatar"></p>
<h2 id="函数族"><a class="markdownIt-Anchor" href="#函数族"></a> 函数族</h2>
<p>◼ int execl(const char *path, const char <em>arg, …/</em> (char *) NULL */);<br>
◼ int execlp(const char *file, const char <em>arg, … /</em> (char *) NULL */);<br>
◼ int execle(const char *path, const char <em>arg, …/</em>, (char *) NULL, char *const envp[] */);<br>
◼ int execv(const char *path, char *const argv[]);<br>
◼ int execvp(const char *file, char *const argv[]);<br>
◼ int execvpe(const char *file, char *const argv[], char *const envp[]);<br>
◼ int execve(const char *filename, char *const argv[], char *const envp[]);</p>
<p>l(list) 参数地址列表，以空指针结尾<br>
v(vector) 存有各参数地址的指针数组的地址<br>
p(path) 按 PATH 环境变量指定的目录搜索可执行文件<br>
e(environment) 存有环境变量字符串地址的指针数组的地址</p>
<h3 id="execl函数"><a class="markdownIt-Anchor" href="#execl函数"></a> execl函数</h3>
<blockquote>
<p>#include &lt;unistd.h&gt;<br>
int execl(const char *path, const char <em>arg, …/</em> (char *) NULL */);</p>
<p>参数：<br>
 path: 需要指定的执行文件的路径或者名称<br>
  a.out /home/coder/a.out<br>
 arg：可执行文件需要的参数列表<br>
  第一个参数一般没有什么作用，为了方便，一般写的是执行程序的名称。<br>
  从第二个参数开始，写的是需要的参数列表。<br>
  参数最后需要以NULL结束（哨兵）。<br>
返回值：<br>
 只有当调用错误才会有返回值，返回-1，设置errno.<br>
 调用成功，没有返回值。</p>
</blockquote>
<h3 id="execlp函数"><a class="markdownIt-Anchor" href="#execlp函数"></a> execlp函数</h3>
<blockquote>
<p>#include &lt;unistd.h&gt;<br>
int execlp(const char *file, const char <em>arg, … /</em> (char *) NULL */);</p>
<p><strong>会到环境变量</strong> <em>(env 查看PATH)</em> <strong>中查找指定的可执行文件，如果找到了就执行，否则执行失败</strong></p>
<p>参数：<br>
 file: 需要指定的可执行文件的文件名<br>
  a.out 即可<br>
 arg：可执行文件需要的参数列表<br>
  第一个参数一般没有什么作用，为了方便，一般写的是执行程序的名称。<br>
  从第二个参数开始，写的是需要的参数列表。<br>
  参数最后需要以NULL结束（哨兵）。<br>
返回值：<br>
 只有当调用错误才会有返回值，返回-1，设置errno.<br>
 调用成功，没有返回值。</p>
</blockquote>
]]></content>
      <categories>
        <category>项目基础</category>
      </categories>
      <tags>
        <tag>exec</tag>
      </tags>
  </entry>
  <entry>
    <title>项目基础——Linux编程——库</title>
    <url>/2023/03/08/%E9%A1%B9%E7%9B%AE%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>Linux高并发服务器开发（from NowCoder）<br>
库的相关操作</p>
<span id="more"></span>
<h2 id="环境搭建"><a class="markdownIt-Anchor" href="#环境搭建"></a> 环境搭建：</h2>
<p>VmWare虚拟机；Xshell远程连接，WinSCP文件传输；VS Code</p>
<h2 id="配置虚拟环境"><a class="markdownIt-Anchor" href="#配置虚拟环境"></a> 配置虚拟环境</h2>
<p>网络配置，使用NAT模式，这个可以再了解一下，面试会问到。</p>
<h2 id="固定系统ip"><a class="markdownIt-Anchor" href="#固定系统ip"></a> 固定系统ip</h2>
<p>为了防止ip动态变化，需要更改Ubuntu的网络配置文件。<br>
gcc 和 g++的使用以及区别</p>
<h2 id="静态库动态库共享库"><a class="markdownIt-Anchor" href="#静态库动态库共享库"></a> 静态库&amp;动态库(共享库)</h2>
<h3 id="静态库命名规则"><a class="markdownIt-Anchor" href="#静态库命名规则"></a> 静态库命名规则：</h3>
<pre><code>Linux: libxxx.a
 lib: 前缀
 xxx: 自定义库名称
 .a: 后缀
Windows: libxxx.lib
</code></pre>
<h3 id="静态库的制作"><a class="markdownIt-Anchor" href="#静态库的制作"></a> 静态库的制作：</h3>
<pre><code>gcc获得.o文件
将.o文件打包，使用ar工具（archive）
 ar rcs libxxx.a xxx.o xxx.o
  r - 将文件插入备份文件中
  c - 建立备存文件
  s - 索引
</code></pre>
<h3 id="静态库的使用"><a class="markdownIt-Anchor" href="#静态库的使用"></a> 静态库的使用：</h3>
<pre><code>gcc -o app main.c -I ./include -l calc -L ./lib
 -I 添加头文件
 -l 指明库名称（不是库文件名称）
 -L 指出库的路径
</code></pre>
<h3 id="动态库命名规则"><a class="markdownIt-Anchor" href="#动态库命名规则"></a> 动态库命名规则：</h3>
<pre><code>Linux: libxxx.so
 lib: 前缀
 xxx: 自定义库名称
 .so: 后缀
 在Linux下是一个可执行文件
Windows: libxxx.dll
</code></pre>
<h3 id="动态库的制作"><a class="markdownIt-Anchor" href="#动态库的制作"></a> 动态库的制作：</h3>
<pre><code>gcc得到.o文件，得到和位置无关的代码
 gcc -c -fpic/fPIC a.c b.c
gcc得到动态库
 gcc -shared a.o b.o -o libcalc.so
</code></pre>
<p>动态库在链接阶段不会被打包到可执行程序中，而是在程序运行后，当使用到动态库里的API时，由动态载入器获取动态库的绝对路径，找到后再将其载入内存。</p>
<h3 id="查看动态库依赖关系"><a class="markdownIt-Anchor" href="#查看动态库依赖关系"></a> 查看动态库依赖关系</h3>
<pre><code>ldd xxx
 xxx: 可执行程序名
</code></pre>
<h3 id="动态库配置"><a class="markdownIt-Anchor" href="#动态库配置"></a> 动态库配置</h3>
<p>1.配置环境变量LD_LIBRARY_PATH</p>
<pre><code>暂时配置：
 终端执行命令: export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:动态库绝对路径

 永久配置：
  用户级：
   vim ~/.bashrc
   在末尾添加: export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:动态库绝对路径
   修改完成后使修改生效，执行: . ~/.bashrc 或者 source ~/.bashrc

  系统级：
   sudo vim /etc/profile
   在末尾添加: export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:动态库绝对路径
   修改完成后使修改生效，执行: source /etc/profile
</code></pre>
<p>2.修改 /etc/ld.so.cache 文件</p>
<pre><code>sudo vim /etc/ld.so.conf
把动态库的绝对路径添加进去
修改完成后更新，执行: sudo ldconfig
</code></pre>
<p>3.在 /lib/, /usr/lib 目录下修改</p>
<pre><code>不建议使用
</code></pre>
<h3 id="优缺点和使用"><a class="markdownIt-Anchor" href="#优缺点和使用"></a> 优缺点和使用</h3>
<p>如果库比较小，考虑使用静态库，反之，使用动态库</p>
<ol>
<li>静态库<br>
优点：加载速度快；发布程序无需提供静态库，移植方便<br>
缺点：消耗系统资源；更新、部署、发布麻烦</li>
<li>动态库<br>
优点：可以实现进程资源共享；更新、部署、发布简单；可以控制何时加载<br>
缺点：加载速度比静态库慢；发布程序时需要提供动态库</li>
</ol>
]]></content>
      <categories>
        <category>项目基础</category>
      </categories>
      <tags>
        <tag>库</tag>
      </tags>
  </entry>
</search>
